---
description: Core coding guidelines and standards for the project
alwaysApply: true
---

# Coding Guidelines

## Documentation

- **Document very well**: Add clear comments and JSDoc where behaviour is non-obvious or APIs are public.
- Document intent, edge cases, and non-obvious assumptions.
- Keep docs close to the code they describe.

## TypeScript

- **Do not use `any` or `unknown`**: Prefer explicit types everywhere.
- If a type is complex or used in multiple places, define it once and reuse it.

## DRY (Don't Repeat Yourself)

- Extract repeated logic into shared functions or modules.
- If you write the same pattern more than once, factor it out.

## File Organisation

- **Split large files up**: Keep files focused and reasonably sized.
- One primary concern per file; extract sub-modules when a file grows unwieldy.

## Types and Imports

- **Don't inline types**: Define types, interfaces, and type aliases in dedicated declarations (either in the same file for local use or in a shared types module).
- **Don't inline imports**: Put each import on its own line; avoid chained or inline import expressions.

```typescript
// ❌ BAD – inline type
function process(data: { id: string; name: string }) {}

// ✅ GOOD – named type
interface ProcessInput {
  id: string;
  name: string;
}
function process(data: ProcessInput) {}
```

## Exports

- **No barrel exports**: Never use `export * from`. Always use explicit named re-exports so the public surface is clear and tree-shaking works reliably.
- **No default exports**: Always use named exports. Default exports make renaming implicit, hurt grep-ability, and lead to inconsistent import names across the codebase.

```typescript
// ❌ BAD – barrel export
export * from './utils';

// ✅ GOOD – explicit named re-exports
export { formatDate } from './format-date';
export { parseConfig } from './parse-config';
```

```typescript
// ❌ BAD – default export
export default function formatDate(date: Date): string { /* ... */ }

// ✅ GOOD – named export
export function formatDate(date: Date): string { /* ... */ }
```

## Object-Oriented Style

- **Prefer object-factory pattern over `class`** wherever plausible.
- Use plain functions that return objects with methods; avoids `this` binding issues and plays well with composition.

```typescript
// ❌ BAD – class
class Recorder {
  constructor(private config: Config) {}
  start() { /* ... */ }
}

// ✅ GOOD – object factory
interface Recorder {
  start: () => void;
}
function createRecorder(config: Config): Recorder {
  return {
    start() { /* ... */ },
  };
}
```

## Iteration

- **Prefer `for...of` over `.forEach()`** for loops.
- `for...of` allows `break`, `continue`, and `return`; is often faster; and avoids callback scope issues.

## Error Handling

- Never swallow errors silently; always log or rethrow with context.
- Use custom error classes for domain-specific failures.
- Avoid empty `catch` blocks.

## Naming

- Use descriptive names; avoid abbreviations except common ones (e.g. `id`, `url`).
- Use camelCase for variables/functions; PascalCase for types and components.

## Functions

- Keep functions small and single-purpose.
- Prefer an options object when a function has three or more parameters.

## Magic Values

- Extract magic numbers and string literals into named constants.
- Document non-obvious values.

## Async

- Prefer `async`/`await` over raw `Promise` chains.
- Handle all promise rejections explicitly.

## Comments

- Prefer self-documenting code; comment *why*, not *what*.
- Delete obsolete or redundant comments.

## Rendering and Client Components

- **Server-side rendering by default**: Next.js pages are server components unless marked otherwise. Prefer SSR where possible for performance and SEO.
- **Client components are fine**: Use `"use client"` freely for interactive tool pages. Most tool pages will need client-side state and that is expected.
- **Keep page shells server-rendered when practical**: If a tool page can render a meaningful static shell (heading, description) on the server and delegate interactivity to a child client component, prefer that pattern. It is not required — a fully client-rendered page is acceptable when the split adds no value.

## SEO and Metadata

- **Every tool page must export `metadata`** (or `generateMetadata`) with at minimum `title`, `description`, and Open Graph fields (`openGraph.title`, `openGraph.description`). Use the shared metadata helpers in `lib/tools-metadata.ts` where available.
- **Keep `app/sitemap.ts` up to date**: When adding or removing a tool, ensure it appears in (or is removed from) the sitemap. The sitemap should be generated from the canonical tool list in `lib/tools.ts`.
- **Keep `app/robots.ts` up to date**: Ensure the robots config allows crawling of all public tool pages and references the sitemap.
- **Canonical tool list is the source of truth**: The tool registry in `lib/tools.ts` drives the home page, sitemap, and any other discovery surface. A new tool is not complete until it is registered there.

## Security

- Validate and sanitise external input at boundaries.
